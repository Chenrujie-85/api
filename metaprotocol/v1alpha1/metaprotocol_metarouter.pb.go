// Copyright Aeraki Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        (unknown)
// source: metaprotocol/v1alpha1/metaprotocol_metarouter.proto

// $schema: metaprotocol.aeraki.io.v1alpha1.MetaRouter
// $title: MetaRouter
// $description: MetaRouter defines route policies for MetaProtocol proxy.
//
// MetaRouter defines route policies for MetaProtocol proxy.
// *Note*: Only one MetaRouter should be defined for a MetaProtocol service.
// If more than one MetaRouters are found for a service, Aeraki will choose
// a random one to apply to that service.
//
// *Note *: MetaRouter is a mesh-scoped resource, so no matter which namespace
// the MetaRouter is in, it will take effect on the services specified in the hosts.
//
// ```yaml
// apiVersion: metaprotocol.aeraki.io/v1alpha1
// kind: MetaRouter
// metadata:
//   name: attribute-based-route
//   namespace: istio-system
// spec:
//   hosts:
//   - org.apache.dubbo.samples.basic.api.demoservice
//   gateways:
//   - istio-system/ingress-gateway
//   routes:
//   - name: v1
//     match:
//       attributes:
//         interface:
//           exact: org.apache.dubbo.samples.basic.api.DemoService
//         method:
//           exact: sayHello
//     route:
//     - destination:
//         host: org.apache.dubbo.samples.basic.api.demoservice
//         subset: v1
//
// ```
//
// ```yaml
// apiVersion: metaprotocol.aeraki.io/v1alpha1
// kind: MetaRouter
// metadata:
//   name: traffic-splitting
// spec:
//   hosts:
//     - org.apache.dubbo.samples.basic.api.demoservice
//   routes:
//     - name: traffic-spilt
//       route:
//         - destination:
//             host: org.apache.dubbo.samples.basic.api.demoservice
//             subset: v1
//           weight: 20
//         - destination:
//             host: org.apache.dubbo.samples.basic.api.demoservice
//             subset: v2
//           weight: 80

package v1alpha1

import (
	duration "github.com/golang/protobuf/ptypes/duration"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MetaRouter defines route policies for MetaProtocol proxy.
//
// <!-- crd generation tags
// +cue-gen:MetaRouter:groupName:metaprotocol.aeraki.io
// +cue-gen:MetaRouter:version:v1alpha1
// +cue-gen:MetaRouter:storageVersion
// +cue-gen:MetaRouter:annotations:helm.sh/resource-policy=keep
// +cue-gen:MetaRouter:labels:app=aeraki,chart=aeraki,heritage=Tiller,release=aeraki
// +cue-gen:MetaRouter:subresource:status
// +cue-gen:MetaRouter:scope:Namespaced
// +cue-gen:MetaRouter:resource:categories=aeraki-io,metaprotocol-aeraki-io
// +cue-gen:MetaRouter:preserveUnknownFields:false
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=metaprotocol.aeraki.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type MetaRouter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The destination service to which traffic is being sent.
	// *Note for Kubernetes users*: It must be a fully qualified domain name
	// (FQDN), (e.g. "thrift-sample-server.meta-thrift.svc.cluster.local" )
	// instead of a short name (e.g. "thrift-sample-server").
	// *Note*: Only one host is supported now. If multiple hosts are specified,
	// Only the first one takes effect.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts,proto3" json:"hosts,omitempty"`
	// The names of gateways and sidecars that should apply these routes. The usage of
	//
	//	this field is the same as istio.io/VirtualService
	Gateways []string `protobuf:"bytes,2,rep,name=gateways,proto3" json:"gateways,omitempty"`
	// An ordered list of route rules for MetaProtocol traffic. The route rules
	// will be applied to service ports named "tcp-metaprotocol-${applicationProtocol}-*",
	// (e.g. "tcp-metaprotocol-thrift-hello-server"). Order maters in the routes,
	// The first rule matching an incoming request is used.
	Routes []*MetaRoute `protobuf:"bytes,3,rep,name=routes,proto3" json:"routes,omitempty"`
	// Loacal rate limit policy.
	LocalRateLimit *LocalRateLimit `protobuf:"bytes,4,opt,name=local_rate_limit,json=localRateLimit,proto3" json:"local_rate_limit,omitempty"`
	// Global rate limit policy.
	GlobalRateLimit *GlobalRateLimit `protobuf:"bytes,5,opt,name=global_rate_limit,json=globalRateLimit,proto3" json:"global_rate_limit,omitempty"`
	// A list of namespaces to which this MetaRouter is exported. Exporting a
	// MetaRouter allows it to be used by sidecars defined in other namespaces.
	// This feature provides a mechanism for service owners and mesh administrators
	// to control the visibility of MetaRouter across namespace boundaries.
	//
	// If no namespaces are specified then the MetaRouter is exported to all namespaces
	// by default.
	//
	// The value "." is reserved and defines an export to the same namespace that
	// the MetaRouter is declared in. Similarly the value "*" is reserved and
	// defines an export to all namespaces.
	ExportTo []string `protobuf:"bytes,20,rep,name=export_to,json=exportTo,proto3" json:"export_to,omitempty"`
}

func (x *MetaRouter) Reset() {
	*x = MetaRouter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetaRouter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaRouter) ProtoMessage() {}

func (x *MetaRouter) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaRouter.ProtoReflect.Descriptor instead.
func (*MetaRouter) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{0}
}

func (x *MetaRouter) GetHosts() []string {
	if x != nil {
		return x.Hosts
	}
	return nil
}

func (x *MetaRouter) GetGateways() []string {
	if x != nil {
		return x.Gateways
	}
	return nil
}

func (x *MetaRouter) GetRoutes() []*MetaRoute {
	if x != nil {
		return x.Routes
	}
	return nil
}

func (x *MetaRouter) GetLocalRateLimit() *LocalRateLimit {
	if x != nil {
		return x.LocalRateLimit
	}
	return nil
}

func (x *MetaRouter) GetGlobalRateLimit() *GlobalRateLimit {
	if x != nil {
		return x.GlobalRateLimit
	}
	return nil
}

func (x *MetaRouter) GetExportTo() []string {
	if x != nil {
		return x.ExportTo
	}
	return nil
}

// Describes match conditions and actions for routing MetaProtocol.
type MetaRoute struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name assigned to the route for debugging purposes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Match conditions to be satisfied for the rule to be activated.
	// All conditions inside a single match block have AND semantic.
	Match *MetaRouteMatch `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// A Route rule can forward (default) traffic. The forwarding target
	// can be one of several versions of a service (see glossary in
	// beginning of document). Weights associated with the service version
	// determine the proportion of traffic it receives.
	Route  []*MetaRouteDestination `protobuf:"bytes,3,rep,name=route,proto3" json:"route,omitempty"`
	Mirror *Destination            `protobuf:"bytes,5,opt,name=mirror,proto3" json:"mirror,omitempty"`
	// Percentage of the traffic to be mirrored by the `mirror` field.
	// If this field is absent, all the traffic (100%) will be mirrored.
	// Max value is 100.
	MirrorPercentage *Percent `protobuf:"bytes,6,opt,name=mirror_percentage,json=mirrorPercentage,proto3" json:"mirror_percentage,omitempty"`
	// Specifies a list of key-value pairs that should be mutated for each request. How to interpret the key-value pairs
	// depends on the codec implementation
	RequestMutation []*KeyValue `protobuf:"bytes,19,rep,name=request_mutation,json=requestMutation,proto3" json:"request_mutation,omitempty"`
	// Specifies a list of key-value pairs that should be mutated for each response. How to interpret the key-value pairs
	// depends on the codec implementation
	ResponseMutation []*KeyValue `protobuf:"bytes,20,rep,name=response_mutation,json=responseMutation,proto3" json:"response_mutation,omitempty"`
}

func (x *MetaRoute) Reset() {
	*x = MetaRoute{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetaRoute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaRoute) ProtoMessage() {}

func (x *MetaRoute) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaRoute.ProtoReflect.Descriptor instead.
func (*MetaRoute) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{1}
}

func (x *MetaRoute) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MetaRoute) GetMatch() *MetaRouteMatch {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *MetaRoute) GetRoute() []*MetaRouteDestination {
	if x != nil {
		return x.Route
	}
	return nil
}

func (x *MetaRoute) GetMirror() *Destination {
	if x != nil {
		return x.Mirror
	}
	return nil
}

func (x *MetaRoute) GetMirrorPercentage() *Percent {
	if x != nil {
		return x.MirrorPercentage
	}
	return nil
}

func (x *MetaRoute) GetRequestMutation() []*KeyValue {
	if x != nil {
		return x.RequestMutation
	}
	return nil
}

func (x *MetaRoute) GetResponseMutation() []*KeyValue {
	if x != nil {
		return x.ResponseMutation
	}
	return nil
}

// KeyValue defines a Key /value pair.
type KeyValue struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Key name.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// alue.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *KeyValue) Reset() {
	*x = KeyValue{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *KeyValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyValue) ProtoMessage() {}

func (x *KeyValue) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyValue.ProtoReflect.Descriptor instead.
func (*KeyValue) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{2}
}

func (x *KeyValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyValue) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type MetaRouteMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// If the value is empty and only the name of attribute is specified, presence of the attribute is checked.
	Attributes map[string]*StringMatch `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *MetaRouteMatch) Reset() {
	*x = MetaRouteMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetaRouteMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaRouteMatch) ProtoMessage() {}

func (x *MetaRouteMatch) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaRouteMatch.ProtoReflect.Descriptor instead.
func (*MetaRouteMatch) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{3}
}

func (x *MetaRouteMatch) GetAttributes() map[string]*StringMatch {
	if x != nil {
		return x.Attributes
	}
	return nil
}

// Describes how to match a given string in HTTP headers. Match is
// case-sensitive.
type StringMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to MatchType:
	//
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	MatchType isStringMatch_MatchType `protobuf_oneof:"match_type"`
}

func (x *StringMatch) Reset() {
	*x = StringMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *StringMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringMatch) ProtoMessage() {}

func (x *StringMatch) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringMatch.ProtoReflect.Descriptor instead.
func (*StringMatch) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{4}
}

func (m *StringMatch) GetMatchType() isStringMatch_MatchType {
	if m != nil {
		return m.MatchType
	}
	return nil
}

func (x *StringMatch) GetExact() string {
	if x, ok := x.GetMatchType().(*StringMatch_Exact); ok {
		return x.Exact
	}
	return ""
}

func (x *StringMatch) GetPrefix() string {
	if x, ok := x.GetMatchType().(*StringMatch_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (x *StringMatch) GetRegex() string {
	if x, ok := x.GetMatchType().(*StringMatch_Regex); ok {
		return x.Regex
	}
	return ""
}

type isStringMatch_MatchType interface {
	isStringMatch_MatchType()
}

type StringMatch_Exact struct {
	// exact string match
	Exact string `protobuf:"bytes,1,opt,name=exact,proto3,oneof"`
}

type StringMatch_Prefix struct {
	// prefix-based match
	Prefix string `protobuf:"bytes,2,opt,name=prefix,proto3,oneof"`
}

type StringMatch_Regex struct {
	// RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*StringMatch_Exact) isStringMatch_MatchType() {}

func (*StringMatch_Prefix) isStringMatch_MatchType() {}

func (*StringMatch_Regex) isStringMatch_MatchType() {}

type MetaRouteDestination struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Destination uniquely identifies the instances of a service
	// to which the request/connection should be forwarded to.
	Destination *Destination `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// The proportion of traffic to be forwarded to the service
	// version. (0-100). Sum of weights across destinations SHOULD BE == 100.
	// If there is only one destination in a rule, the weight value is assumed to
	// be 100.
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (x *MetaRouteDestination) Reset() {
	*x = MetaRouteDestination{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetaRouteDestination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetaRouteDestination) ProtoMessage() {}

func (x *MetaRouteDestination) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetaRouteDestination.ProtoReflect.Descriptor instead.
func (*MetaRouteDestination) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{5}
}

func (x *MetaRouteDestination) GetDestination() *Destination {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *MetaRouteDestination) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type Destination struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The name of a service from the service registry. Service
	// names are looked up from the platform's service registry (e.g.,
	// Kubernetes services, Consul services, etc.) and from the hosts
	// declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic
	// forwarded to destinations that are not found in either of the two, will be dropped.
	//
	// *Note for Kubernetes users*: When short names are used (e.g. "reviews"
	// instead of "reviews.default.svc.cluster.local"), Istio will interpret
	// the short name based on the namespace of the rule, not the service. A
	// rule in the "default" namespace containing a host "reviews will be
	// interpreted as "reviews.default.svc.cluster.local", irrespective of
	// the actual namespace associated with the reviews service. To avoid
	// potential misconfiguration, it is recommended to always use fully
	// qualified domain names over short names.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The name of a subset within the service. Applicable only to services
	// within the mesh. The subset must be defined in a corresponding
	// DestinationRule.
	Subset string `protobuf:"bytes,2,opt,name=subset,proto3" json:"subset,omitempty"`
	// Specifies the port on the host that is being addressed. If a service
	// exposes only a single port it is not required to explicitly select the
	// port.
	Port *PortSelector `protobuf:"bytes,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (x *Destination) Reset() {
	*x = Destination{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Destination) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Destination) ProtoMessage() {}

func (x *Destination) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Destination.ProtoReflect.Descriptor instead.
func (*Destination) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{6}
}

func (x *Destination) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *Destination) GetSubset() string {
	if x != nil {
		return x.Subset
	}
	return ""
}

func (x *Destination) GetPort() *PortSelector {
	if x != nil {
		return x.Port
	}
	return nil
}

// PortSelector specifies the number of a port to be used for
// matching or selection for final routing.
type PortSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Valid port number
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
}

func (x *PortSelector) Reset() {
	*x = PortSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PortSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortSelector) ProtoMessage() {}

func (x *PortSelector) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortSelector.ProtoReflect.Descriptor instead.
func (*PortSelector) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{7}
}

func (x *PortSelector) GetNumber() uint32 {
	if x != nil {
		return x.Number
	}
	return 0
}

// LocalRateLimit defines local rate limit policies for MetaProtocol proxy
type LocalRateLimit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The default token bucket configuration to use for rate limiting requests that are processed by
	// this filter.
	// Local rate limiter will first check the conditions, if a specific condition matches, then the token
	// bucket within that condition will be applied to the incoming request. All the other requests
	// that don't match the conditions will be rate limited by the default token bucket.
	// If the default token bucket is not specified, then the requests that don't match the conditions
	// will not be rate limited.
	// At least one of token_bucket or conditions should have value.
	TokenBucket *LocalRateLimit_TokenBucket `protobuf:"bytes,1,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
	// The more specific rate limit conditions, the first match will be used.
	Conditions []*LocalRateLimit_Condition `protobuf:"bytes,2,rep,name=conditions,proto3" json:"conditions,omitempty"`
}

func (x *LocalRateLimit) Reset() {
	*x = LocalRateLimit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LocalRateLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocalRateLimit) ProtoMessage() {}

func (x *LocalRateLimit) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocalRateLimit.ProtoReflect.Descriptor instead.
func (*LocalRateLimit) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{8}
}

func (x *LocalRateLimit) GetTokenBucket() *LocalRateLimit_TokenBucket {
	if x != nil {
		return x.TokenBucket
	}
	return nil
}

func (x *LocalRateLimit) GetConditions() []*LocalRateLimit_Condition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

// GlobalRateLimit configures global rate limit service for MetaProtocol proxy
type GlobalRateLimit struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Match conditions to be satisfied for the rate limit rule to be activated.
	// All conditions inside a single match block have AND semantic.
	// If the match is not specified, then all the incoming requests will be considered matched.
	Match *MetaRouteMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// The rate limit domain to use when calling the rate limit service.
	Domain string `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
	// The timeout in milliseconds for the rate limit service RPC. If not
	// set, this defaults to 20ms.
	RequestTimeout *duration.Duration `protobuf:"bytes,3,opt,name=request_timeout,json=requestTimeout,proto3" json:"request_timeout,omitempty"`
	// The filter's behavior in case the rate limiting service does
	// not respond back. When it is set to true, Envoy will not allow traffic in case of
	// communication failure between rate limiting service and the proxy.
	DenyOnFail bool `protobuf:"varint,4,opt,name=deny_on_fail,json=denyOnFail,proto3" json:"deny_on_fail,omitempty"`
	// The cluster name of the external rate limit service provider.
	RateLimitService string `protobuf:"bytes,5,opt,name=rate_limit_service,json=rateLimitService,proto3" json:"rate_limit_service,omitempty"`
	// Defines what properties in the requests should be sent to the rate limit service
	Descriptors []*GlobalRateLimit_Descriptor `protobuf:"bytes,6,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
}

func (x *GlobalRateLimit) Reset() {
	*x = GlobalRateLimit{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GlobalRateLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalRateLimit) ProtoMessage() {}

func (x *GlobalRateLimit) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalRateLimit.ProtoReflect.Descriptor instead.
func (*GlobalRateLimit) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{9}
}

func (x *GlobalRateLimit) GetMatch() *MetaRouteMatch {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *GlobalRateLimit) GetDomain() string {
	if x != nil {
		return x.Domain
	}
	return ""
}

func (x *GlobalRateLimit) GetRequestTimeout() *duration.Duration {
	if x != nil {
		return x.RequestTimeout
	}
	return nil
}

func (x *GlobalRateLimit) GetDenyOnFail() bool {
	if x != nil {
		return x.DenyOnFail
	}
	return false
}

func (x *GlobalRateLimit) GetRateLimitService() string {
	if x != nil {
		return x.RateLimitService
	}
	return ""
}

func (x *GlobalRateLimit) GetDescriptors() []*GlobalRateLimit_Descriptor {
	if x != nil {
		return x.Descriptors
	}
	return nil
}

// Percent specifies a percentage in the range of [0.0, 100.0].
type Percent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value float64 `protobuf:"fixed64,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Percent) Reset() {
	*x = Percent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Percent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Percent) ProtoMessage() {}

func (x *Percent) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Percent.ProtoReflect.Descriptor instead.
func (*Percent) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{10}
}

func (x *Percent) GetValue() float64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// Configures a token bucket which is used for rate limiting.
type LocalRateLimit_TokenBucket struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
	// initially contains. The value must be greater than 0.
	MaxTokens uint32 `protobuf:"varint,1,opt,name=max_tokens,json=maxTokens,proto3" json:"max_tokens,omitempty"`
	// The number of tokens added to the bucket during each fill interval. The value must be greater than 0.
	// If not specified, defaults to a single token.
	TokensPerFill *wrappers.UInt32Value `protobuf:"bytes,2,opt,name=tokens_per_fill,json=tokensPerFill,proto3" json:"tokens_per_fill,omitempty"`
	// The fill interval that tokens are added to the bucket. During each fill interval
	// `tokens_per_fill` are added to the bucket. The bucket will never contain more than
	// `max_tokens` tokens.
	FillInterval *duration.Duration `protobuf:"bytes,3,opt,name=fill_interval,json=fillInterval,proto3" json:"fill_interval,omitempty"`
}

func (x *LocalRateLimit_TokenBucket) Reset() {
	*x = LocalRateLimit_TokenBucket{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LocalRateLimit_TokenBucket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocalRateLimit_TokenBucket) ProtoMessage() {}

func (x *LocalRateLimit_TokenBucket) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocalRateLimit_TokenBucket.ProtoReflect.Descriptor instead.
func (*LocalRateLimit_TokenBucket) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{8, 0}
}

func (x *LocalRateLimit_TokenBucket) GetMaxTokens() uint32 {
	if x != nil {
		return x.MaxTokens
	}
	return 0
}

func (x *LocalRateLimit_TokenBucket) GetTokensPerFill() *wrappers.UInt32Value {
	if x != nil {
		return x.TokensPerFill
	}
	return nil
}

func (x *LocalRateLimit_TokenBucket) GetFillInterval() *duration.Duration {
	if x != nil {
		return x.FillInterval
	}
	return nil
}

// Condition defines a rate limit policy for a more specific condition
type LocalRateLimit_Condition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Match conditions to be satisfied for the rate limit rule to be activated.
	// All conditions inside a single match block have AND semantic.
	// If the match is not specified, then all the incoming requests will be considered matched.
	Match *MetaRouteMatch `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// The token bucket for this particular condition
	TokenBucket *LocalRateLimit_TokenBucket `protobuf:"bytes,2,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
}

func (x *LocalRateLimit_Condition) Reset() {
	*x = LocalRateLimit_Condition{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LocalRateLimit_Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocalRateLimit_Condition) ProtoMessage() {}

func (x *LocalRateLimit_Condition) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocalRateLimit_Condition.ProtoReflect.Descriptor instead.
func (*LocalRateLimit_Condition) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{8, 1}
}

func (x *LocalRateLimit_Condition) GetMatch() *MetaRouteMatch {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *LocalRateLimit_Condition) GetTokenBucket() *LocalRateLimit_TokenBucket {
	if x != nil {
		return x.TokenBucket
	}
	return nil
}

// Descriptor defines the mapping between the property in the request and the descriptor key in the rate
// limit server configuration
// Normally the property is the same as the descriptor key, but adding a mapping layer allows more flexibility
type GlobalRateLimit_Descriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The property extracted from the requests
	Property string `protobuf:"bytes,1,opt,name=property,proto3" json:"property,omitempty"`
	// The corresponding descriptor key in the rate limit server configuration
	DescriptorKey string `protobuf:"bytes,2,opt,name=descriptor_key,json=descriptorKey,proto3" json:"descriptor_key,omitempty"`
}

func (x *GlobalRateLimit_Descriptor) Reset() {
	*x = GlobalRateLimit_Descriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *GlobalRateLimit_Descriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GlobalRateLimit_Descriptor) ProtoMessage() {}

func (x *GlobalRateLimit_Descriptor) ProtoReflect() protoreflect.Message {
	mi := &file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GlobalRateLimit_Descriptor.ProtoReflect.Descriptor instead.
func (*GlobalRateLimit_Descriptor) Descriptor() ([]byte, []int) {
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP(), []int{9, 0}
}

func (x *GlobalRateLimit_Descriptor) GetProperty() string {
	if x != nil {
		return x.Property
	}
	return ""
}

func (x *GlobalRateLimit_Descriptor) GetDescriptorKey() string {
	if x != nil {
		return x.DescriptorKey
	}
	return ""
}

var File_metaprotocol_v1alpha1_metaprotocol_metarouter_proto protoreflect.FileDescriptor

var file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDesc = []byte{
	0x0a, 0x33, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2f, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1f, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61,
	0x70, 0x69, 0x2f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f,
	0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72,
	0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xd8, 0x02, 0x0a, 0x0a, 0x4d, 0x65, 0x74, 0x61,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x12, 0x1a, 0x0a, 0x08,
	0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08,
	0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x73, 0x12, 0x42, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74,
	0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69,
	0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x52, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x59, 0x0a, 0x10,
	0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x52, 0x61,
	0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x52, 0x0e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x52, 0x61,
	0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x5c, 0x0a, 0x11, 0x67, 0x6c, 0x6f, 0x62, 0x61,
	0x6c, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x30, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x61, 0x74, 0x65, 0x4c,
	0x69, 0x6d, 0x69, 0x74, 0x52, 0x0f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x61, 0x74, 0x65,
	0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x5f,
	0x74, 0x6f, 0x18, 0x14, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74,
	0x54, 0x6f, 0x22, 0xfe, 0x03, 0x0a, 0x09, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x6e, 0x61, 0x6d, 0x65, 0x12, 0x45, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x4b, 0x0a, 0x05, 0x72,
	0x6f, 0x75, 0x74, 0x65, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x6d, 0x65, 0x74,
	0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69,
	0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74,
	0x61, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x05, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x44, 0x0a, 0x06, 0x6d, 0x69, 0x72, 0x72,
	0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69,
	0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x44, 0x65, 0x73, 0x74, 0x69,
	0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x6d, 0x69, 0x72, 0x72, 0x6f, 0x72, 0x12, 0x55,
	0x0a, 0x11, 0x6d, 0x69, 0x72, 0x72, 0x6f, 0x72, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74,
	0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x6d, 0x65, 0x74, 0x61,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e,
	0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x65, 0x72, 0x63,
	0x65, 0x6e, 0x74, 0x52, 0x10, 0x6d, 0x69, 0x72, 0x72, 0x6f, 0x72, 0x50, 0x65, 0x72, 0x63, 0x65,
	0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x54, 0x0a, 0x10, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x5f, 0x6d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x13, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61,
	0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x4b, 0x65, 0x79, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0f, 0x72, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x4d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x56, 0x0a, 0x11, 0x72,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x6d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x18, 0x14, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4b, 0x65, 0x79, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x52, 0x10, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x4d, 0x75, 0x74, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x22, 0x3e, 0x0a, 0x08, 0x4b, 0x65, 0x79, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12,
	0x16, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x04, 0xe2, 0x41,
	0x01, 0x02, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x1a, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x05, 0x76, 0x61,
	0x6c, 0x75, 0x65, 0x22, 0xde, 0x01, 0x0a, 0x0e, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x6f, 0x75, 0x74,
	0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x5f, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62,
	0x75, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e, 0x6d, 0x65, 0x74,
	0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69,
	0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74,
	0x61, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x41, 0x74, 0x74, 0x72,
	0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x61, 0x74, 0x74,
	0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x1a, 0x6b, 0x0a, 0x0f, 0x41, 0x74, 0x74, 0x72, 0x69,
	0x62, 0x75, 0x74, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x42, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6d, 0x65,
	0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b,
	0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x53, 0x74,
	0x72, 0x69, 0x6e, 0x67, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x3a, 0x02, 0x38, 0x01, 0x22, 0x65, 0x0a, 0x0b, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x12, 0x16, 0x0a, 0x05, 0x65, 0x78, 0x61, 0x63, 0x74, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x48, 0x00, 0x52, 0x05, 0x65, 0x78, 0x61, 0x63, 0x74, 0x12, 0x18, 0x0a, 0x06, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x06, 0x70,
	0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x05, 0x72, 0x65, 0x67, 0x65, 0x78, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x05, 0x72, 0x65, 0x67, 0x65, 0x78, 0x42, 0x0c, 0x0a,
	0x0a, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x84, 0x01, 0x0a, 0x14,
	0x4d, 0x65, 0x74, 0x61, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x54, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6d, 0x65, 0x74, 0x61,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e,
	0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x44, 0x65, 0x73, 0x74,
	0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x0b, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x77, 0x65,
	0x69, 0x67, 0x68, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x77, 0x65, 0x69, 0x67,
	0x68, 0x74, 0x22, 0x82, 0x01, 0x0a, 0x0b, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06,
	0x73, 0x75, 0x62, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x75,
	0x62, 0x73, 0x65, 0x74, 0x12, 0x41, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x22, 0x32, 0x0a, 0x0c, 0x50, 0x6f, 0x72, 0x74, 0x53,
	0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65,
	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x4a,
	0x04, 0x08, 0x02, 0x10, 0x03, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0xc7, 0x04, 0x0a, 0x0e,
	0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x5e,
	0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31,
	0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x52, 0x61, 0x74, 0x65,
	0x4c, 0x69, 0x6d, 0x69, 0x74, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x42, 0x75, 0x63, 0x6b, 0x65,
	0x74, 0x52, 0x0b, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x59,
	0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x39, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f,
	0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69,
	0x6d, 0x69, 0x74, 0x2e, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x63,
	0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0xb8, 0x01, 0x0a, 0x0b, 0x54, 0x6f,
	0x6b, 0x65, 0x6e, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x78,
	0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x09, 0x6d,
	0x61, 0x78, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x12, 0x44, 0x0a, 0x0f, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x73, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x66, 0x69, 0x6c, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x62, 0x75, 0x66, 0x2e, 0x55, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52,
	0x0d, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x50, 0x65, 0x72, 0x46, 0x69, 0x6c, 0x6c, 0x12, 0x44,
	0x0a, 0x0d, 0x66, 0x69, 0x6c, 0x6c, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x0c, 0x66, 0x69, 0x6c, 0x6c, 0x49, 0x6e, 0x74, 0x65,
	0x72, 0x76, 0x61, 0x6c, 0x1a, 0xbe, 0x01, 0x0a, 0x09, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x4b, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2f, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
	0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12,
	0x64, 0x0a, 0x0c, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x52, 0x61, 0x74,
	0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x2e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x42, 0x75, 0x63, 0x6b,
	0x65, 0x74, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x0b, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x42,
	0x75, 0x63, 0x6b, 0x65, 0x74, 0x22, 0xd8, 0x03, 0x0a, 0x0f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
	0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x4b, 0x0a, 0x05, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69,
	0x6f, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x61, 0x52,
	0x6f, 0x75, 0x74, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52,
	0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x1c, 0x0a, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x06, 0x64, 0x6f,
	0x6d, 0x61, 0x69, 0x6e, 0x12, 0x42, 0x0a, 0x0f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x20, 0x0a, 0x0c, 0x64, 0x65, 0x6e, 0x79,
	0x5f, 0x6f, 0x6e, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a,
	0x64, 0x65, 0x6e, 0x79, 0x4f, 0x6e, 0x46, 0x61, 0x69, 0x6c, 0x12, 0x32, 0x0a, 0x12, 0x72, 0x61,
	0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x10, 0x72, 0x61,
	0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x63,
	0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x73, 0x18, 0x06, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
	0x6f, 0x6c, 0x2e, 0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2e, 0x69, 0x6f, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x52, 0x61, 0x74, 0x65,
	0x4c, 0x69, 0x6d, 0x69, 0x74, 0x2e, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72,
	0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x6f, 0x72, 0x73, 0x1a, 0x5b, 0x0a, 0x0a, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f,
	0x72, 0x12, 0x20, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x42, 0x04, 0xe2, 0x41, 0x01, 0x02, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x70, 0x65,
	0x72, 0x74, 0x79, 0x12, 0x2b, 0x0a, 0x0e, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f,
	0x72, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x04, 0xe2, 0x41, 0x01,
	0x02, 0x52, 0x0d, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x4b, 0x65, 0x79,
	0x22, 0x1f, 0x0a, 0x07, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x42, 0x32, 0x5a, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f,
	0x61, 0x65, 0x72, 0x61, 0x6b, 0x69, 0x2d, 0x6d, 0x65, 0x73, 0x68, 0x2f, 0x61, 0x70, 0x69, 0x2f,
	0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2f, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescOnce sync.Once
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescData = file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDesc
)

func file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescGZIP() []byte {
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescOnce.Do(func() {
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescData = protoimpl.X.CompressGZIP(file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescData)
	})
	return file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDescData
}

var file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_goTypes = []interface{}{
	(*MetaRouter)(nil),                 // 0: metaprotocol.aeraki.io.v1alpha1.MetaRouter
	(*MetaRoute)(nil),                  // 1: metaprotocol.aeraki.io.v1alpha1.MetaRoute
	(*KeyValue)(nil),                   // 2: metaprotocol.aeraki.io.v1alpha1.KeyValue
	(*MetaRouteMatch)(nil),             // 3: metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch
	(*StringMatch)(nil),                // 4: metaprotocol.aeraki.io.v1alpha1.StringMatch
	(*MetaRouteDestination)(nil),       // 5: metaprotocol.aeraki.io.v1alpha1.MetaRouteDestination
	(*Destination)(nil),                // 6: metaprotocol.aeraki.io.v1alpha1.Destination
	(*PortSelector)(nil),               // 7: metaprotocol.aeraki.io.v1alpha1.PortSelector
	(*LocalRateLimit)(nil),             // 8: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit
	(*GlobalRateLimit)(nil),            // 9: metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit
	(*Percent)(nil),                    // 10: metaprotocol.aeraki.io.v1alpha1.Percent
	nil,                                // 11: metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch.AttributesEntry
	(*LocalRateLimit_TokenBucket)(nil), // 12: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.TokenBucket
	(*LocalRateLimit_Condition)(nil),   // 13: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.Condition
	(*GlobalRateLimit_Descriptor)(nil), // 14: metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit.Descriptor
	(*duration.Duration)(nil),          // 15: google.protobuf.Duration
	(*wrappers.UInt32Value)(nil),       // 16: google.protobuf.UInt32Value
}
var file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_depIdxs = []int32{
	1,  // 0: metaprotocol.aeraki.io.v1alpha1.MetaRouter.routes:type_name -> metaprotocol.aeraki.io.v1alpha1.MetaRoute
	8,  // 1: metaprotocol.aeraki.io.v1alpha1.MetaRouter.local_rate_limit:type_name -> metaprotocol.aeraki.io.v1alpha1.LocalRateLimit
	9,  // 2: metaprotocol.aeraki.io.v1alpha1.MetaRouter.global_rate_limit:type_name -> metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit
	3,  // 3: metaprotocol.aeraki.io.v1alpha1.MetaRoute.match:type_name -> metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch
	5,  // 4: metaprotocol.aeraki.io.v1alpha1.MetaRoute.route:type_name -> metaprotocol.aeraki.io.v1alpha1.MetaRouteDestination
	6,  // 5: metaprotocol.aeraki.io.v1alpha1.MetaRoute.mirror:type_name -> metaprotocol.aeraki.io.v1alpha1.Destination
	10, // 6: metaprotocol.aeraki.io.v1alpha1.MetaRoute.mirror_percentage:type_name -> metaprotocol.aeraki.io.v1alpha1.Percent
	2,  // 7: metaprotocol.aeraki.io.v1alpha1.MetaRoute.request_mutation:type_name -> metaprotocol.aeraki.io.v1alpha1.KeyValue
	2,  // 8: metaprotocol.aeraki.io.v1alpha1.MetaRoute.response_mutation:type_name -> metaprotocol.aeraki.io.v1alpha1.KeyValue
	11, // 9: metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch.attributes:type_name -> metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch.AttributesEntry
	6,  // 10: metaprotocol.aeraki.io.v1alpha1.MetaRouteDestination.destination:type_name -> metaprotocol.aeraki.io.v1alpha1.Destination
	7,  // 11: metaprotocol.aeraki.io.v1alpha1.Destination.port:type_name -> metaprotocol.aeraki.io.v1alpha1.PortSelector
	12, // 12: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.token_bucket:type_name -> metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.TokenBucket
	13, // 13: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.conditions:type_name -> metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.Condition
	3,  // 14: metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit.match:type_name -> metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch
	15, // 15: metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit.request_timeout:type_name -> google.protobuf.Duration
	14, // 16: metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit.descriptors:type_name -> metaprotocol.aeraki.io.v1alpha1.GlobalRateLimit.Descriptor
	4,  // 17: metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch.AttributesEntry.value:type_name -> metaprotocol.aeraki.io.v1alpha1.StringMatch
	16, // 18: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.TokenBucket.tokens_per_fill:type_name -> google.protobuf.UInt32Value
	15, // 19: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.TokenBucket.fill_interval:type_name -> google.protobuf.Duration
	3,  // 20: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.Condition.match:type_name -> metaprotocol.aeraki.io.v1alpha1.MetaRouteMatch
	12, // 21: metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.Condition.token_bucket:type_name -> metaprotocol.aeraki.io.v1alpha1.LocalRateLimit.TokenBucket
	22, // [22:22] is the sub-list for method output_type
	22, // [22:22] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_init() }
func file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_init() {
	if File_metaprotocol_v1alpha1_metaprotocol_metarouter_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetaRouter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetaRoute); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*KeyValue); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetaRouteMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*StringMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetaRouteDestination); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Destination); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PortSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LocalRateLimit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GlobalRateLimit); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Percent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LocalRateLimit_TokenBucket); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LocalRateLimit_Condition); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GlobalRateLimit_Descriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_goTypes,
		DependencyIndexes: file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_depIdxs,
		MessageInfos:      file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_msgTypes,
	}.Build()
	File_metaprotocol_v1alpha1_metaprotocol_metarouter_proto = out.File
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_rawDesc = nil
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_goTypes = nil
	file_metaprotocol_v1alpha1_metaprotocol_metarouter_proto_depIdxs = nil
}
